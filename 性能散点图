import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error
import os
import warnings

warnings.filterwarnings('ignore')

# 设置中文字体和避免乱码
plt.rcParams['font.sans-serif'] = ['Times New Roman']
plt.rcParams['axes.unicode_minus'] = False
plt.rcParams['font.size'] = 10
# 启用LaTeX渲染以支持上标
plt.rcParams['text.usetex'] = False
plt.rcParams['mathtext.default'] = 'regular'


class ModelPerformanceVisualizer:
    def __init__(self, excel_path=r"F:\Machine leaning_SHAP\Result_Pre_Date.xlsx",
                 output_dir=r"F:\Machine leaning_SHAP\chutu", color_scheme=1):
        """
        初始化模型性能可视化器

        Args:
            excel_path: Excel文件路径
            output_dir: 输出目录路径
            color_scheme: 颜色方案选择 (1-6)
        """
        self.excel_path = excel_path
        self.output_dir = output_dir
        self.color_scheme = color_scheme  # 保存颜色方案编号

        # 创建输出目录
        os.makedirs(self.output_dir, exist_ok=True)

        # 设置默认字体大小
        self.font_sizes = {
            'title': 14,
            'axis_label': 12,
            'tick_label': 10,
            'metrics_text': 10
        }

        # 设置颜色方案
        self.set_color_scheme(color_scheme)

    def set_color_scheme(self, scheme_number):
        """设置红蓝配色方案"""
        # 使用指定的蓝色和红色配色
        self.train_color = '#0173B2'  # 指定的蓝色
        self.test_color = '#d62728'  # 经典红色

        # 设置模型颜色（9个模型）
        self.model_colors = {
            'ANN': {'train': self.train_color, 'test': self.test_color},
            'KNN': {'train': self.train_color, 'test': self.test_color},
            'LightGBM': {'train': self.train_color, 'test': self.test_color},
            'LSTM': {'train': self.train_color, 'test': self.test_color},
            'PLS': {'train': self.train_color, 'test': self.test_color},
            'SVM': {'train': self.train_color, 'test': self.test_color},
            'TabNet': {'train': self.train_color, 'test': self.test_color},
            'XGBoost': {'train': self.train_color, 'test': self.test_color},
            'RF': {'train': self.train_color, 'test': self.test_color}
        }

    def calculate_metrics(self, y_true, y_pred):
        """计算模型性能指标（R²、MAE、RMSE）"""
        # 移除NaN值
        mask = ~(np.isnan(y_true) | np.isnan(y_pred))
        y_true_clean = y_true[mask]
        y_pred_clean = y_pred[mask]

        if len(y_true_clean) == 0:
            return 0, 0, 0  # R², MAE, RMSE

        r2 = r2_score(y_true_clean, y_pred_clean)
        mae = mean_absolute_error(y_true_clean, y_pred_clean)
        mse = mean_squared_error(y_true_clean, y_pred_clean)
        rmse = np.sqrt(mse)

        return r2, mae, rmse

    def load_data_from_excel(self):
        """从Excel文件加载数据"""
        try:
            # 读取训练集和测试集数据
            train_df = pd.read_excel(self.excel_path, sheet_name='train')
            test_df = pd.read_excel(self.excel_path, sheet_name='test')

            print(f"Loaded train data shape: {train_df.shape}")
            print(f"Loaded test data shape: {test_df.shape}")
            print(f"Train columns: {list(train_df.columns)}")
            print(f"Test columns: {list(test_df.columns)}")

            # 解析数据
            predictions = self.parse_excel_data(train_df, test_df)

            return predictions

        except Exception as e:
            print(f"Error loading data: {str(e)}")
            return {}

    def parse_excel_data(self, train_df, test_df):
        """解析Excel数据格式 - 根据Excel截图，正确的列索引从0开始"""
        predictions = {}

        # 根据Excel截图重新定义模型列索引（从1开始，因为第0列可能是索引）
        # 跳过第一行标题，从第二行开始是真实的列标题
        model_info = [
            ('ANN', 0, 1),  # ANN列：真实值，预测值
            ('KNN', 2, 3),  # KNN列：真实值，预测值
            ('LightGBM', 4, 5),  # LightGBM列：真实值，预测值
            ('LSTM', 6, 7),  # LSTM列：真实值，预测值
            ('PLS', 8, 9),  # PLS列：真实值，预测值
            ('SVM', 10, 11),  # SVM列：真实值，预测值
            ('TabNet', 12, 13),  # TabNet列：真实值，预测值
            ('XGBoost', 14, 15),  # XGBoost列：真实值，预测值
            ('RF', 16, 17)  # RF列：真实值，预测值
        ]

        print(f"Parsing data for {len(model_info)} models...")
        print(f"Train data shape: {train_df.shape}")
        print(f"Test data shape: {test_df.shape}")
        print(f"Train data columns count: {len(train_df.columns)}")
        print(f"Test data columns count: {len(test_df.columns)}")

        # 为每个模型提取数据
        for model_name, true_col, pred_col in model_info:
            try:
                print(f"\nTrying to load {model_name} from columns {true_col}, {pred_col}")

                # 检查列是否存在
                if true_col >= len(train_df.columns) or pred_col >= len(train_df.columns):
                    print(f"Warning: Columns for {model_name} do not exist in train data")
                    print(f"  Requested columns: {true_col}, {pred_col}")
                    print(f"  Available columns: {len(train_df.columns)}")
                    continue

                if true_col >= len(test_df.columns) or pred_col >= len(test_df.columns):
                    print(f"Warning: Columns for {model_name} do not exist in test data")
                    print(f"  Requested columns: {true_col}, {pred_col}")
                    print(f"  Available columns: {len(test_df.columns)}")
                    continue

                # 提取训练集真实值和预测值
                train_true = train_df.iloc[:, true_col].values
                train_pred = train_df.iloc[:, pred_col].values

                # 提取测试集真实值和预测值
                test_true = test_df.iloc[:, true_col].values
                test_pred = test_df.iloc[:, pred_col].values

                print(f"  Raw data extracted for {model_name}")
                print(f"  Train true sample: {train_true[:5]}")
                print(f"  Train pred sample: {train_pred[:5]}")

                # 转换为数值类型并移除NaN
                train_true = pd.to_numeric(train_true, errors='coerce')
                train_pred = pd.to_numeric(train_pred, errors='coerce')
                test_true = pd.to_numeric(test_true, errors='coerce')
                test_pred = pd.to_numeric(test_pred, errors='coerce')

                # 移除NaN值
                train_mask = ~(np.isnan(train_true) | np.isnan(train_pred))
                test_mask = ~(np.isnan(test_true) | np.isnan(test_pred))

                train_true_clean = train_true[train_mask]
                train_pred_clean = train_pred[train_mask]
                test_true_clean = test_true[test_mask]
                test_pred_clean = test_pred[test_mask]

                print(f"  After cleaning - Train: {len(train_true_clean)}, Test: {len(test_true_clean)}")

                # 检查数据有效性
                if len(train_true_clean) > 0 and len(test_true_clean) > 0:
                    predictions[model_name] = {
                        'train_true': train_true_clean,
                        'train_pred': train_pred_clean,
                        'test_true': test_true_clean,
                        'test_pred': test_pred_clean
                    }
                    print(f"✓ Successfully loaded {model_name} model data")
                    print(f"  Train samples: {len(train_true_clean)}")
                    print(f"  Test samples: {len(test_true_clean)}")
                else:
                    print(f"✗ Warning: {model_name} model has no valid data after cleaning")

            except Exception as e:
                print(f"✗ Error parsing {model_name} model data: {str(e)}")
                continue

        print(f"\nSuccessfully parsed {len(predictions)} models")
        print(f"Loaded models: {list(predictions.keys())}")
        return predictions

    def create_single_scatter_plot(self, y_true_train, y_pred_train, y_true_test, y_pred_test,
                                   model_name, save_path):
        """创建单个模型的散点图（不显示MSE）"""

        # 计算指标（不包含MSE）
        train_r2, train_mae, train_rmse = self.calculate_metrics(y_true_train, y_pred_train)
        test_r2, test_mae, test_rmse = self.calculate_metrics(y_true_test, y_pred_test)

        # 创建图形
        fig, ax = plt.subplots(figsize=(8, 6))

        # 移除NaN值用于绘图
        train_mask = ~(np.isnan(y_true_train) | np.isnan(y_pred_train))
        test_mask = ~(np.isnan(y_true_test) | np.isnan(y_pred_test))

        train_true_clean = y_true_train[train_mask]
        train_pred_clean = y_pred_train[train_mask]
        test_true_clean = y_true_test[test_mask]
        test_pred_clean = y_pred_test[test_mask]

        # 获取数据范围
        all_values = np.concatenate([train_true_clean, train_pred_clean,
                                     test_true_clean, test_pred_clean])
        if len(all_values) > 0:
            min_val, max_val = np.min(all_values), np.max(all_values)
        else:
            min_val, max_val = -1, 1

        # 先绘制测试集散点图（在下层）
        ax.scatter(test_true_clean, test_pred_clean,
                   c=self.test_color, alpha=0.6, s=4,
                   label='Test Data')

        # 后绘制训练集散点图（在上层）
        ax.scatter(train_true_clean, train_pred_clean,
                   c=self.train_color, alpha=0.6, s=4,
                   label='Training Data')

        # 添加训练集拟合直线
        if len(train_true_clean) > 1:
            z_train = np.polyfit(train_true_clean, train_pred_clean, 1)
            p_train = np.poly1d(z_train)
            ax.plot(train_true_clean, p_train(train_true_clean),
                    color=self.train_color, linestyle='--', linewidth=2, alpha=0.8)

        # 添加测试集拟合直线
        if len(test_true_clean) > 1:
            z_test = np.polyfit(test_true_clean, test_pred_clean, 1)
            p_test = np.poly1d(z_test)
            ax.plot(test_true_clean, p_test(test_true_clean),
                    color=self.test_color, linestyle='--', linewidth=2, alpha=0.8)

        # 绘制1:1线（理想预测线）
        ax.plot([min_val, max_val], [min_val, max_val],
                'k-', linewidth=2, alpha=0.8)

        # 设置坐标轴
        ax.set_xlim(min_val, max_val)
        ax.set_ylim(min_val, max_val)
        ax.set_xlabel('True Value', fontsize=self.font_sizes['axis_label'], fontweight='normal')
        ax.set_ylabel('Predicted Value', fontsize=self.font_sizes['axis_label'], fontweight='normal')

        # 将模型名字放在图框顶部中央（移除加粗）
        ax.text(0.5, 0.95, f'{model_name}', transform=ax.transAxes,
                fontsize=16, fontweight='normal', horizontalalignment='center',
                verticalalignment='top', color='black',
                bbox=dict(boxstyle='round,pad=0.4', edgecolor='black', facecolor='white', linewidth=1.5))

        # 添加训练集指标文本（增大字体大小）
        train_text = f'Train Metrics\n$R^2$: {train_r2:.3f}\nRMSE: {train_rmse:.3f}\nMAE: {train_mae:.3f}'
        ax.text(0.05, 0.82, train_text, transform=ax.transAxes,
                fontsize=10, verticalalignment='top',
                bbox=dict(boxstyle='round', edgecolor=self.train_color, facecolor='none', linewidth=1.5),
                color=self.train_color, fontweight='normal')

        # 添加测试集指标文本（增大字体大小）
        test_text = f'Test Metrics\n$R^2$: {test_r2:.3f}\nRMSE: {test_rmse:.3f}\nMAE: {test_mae:.3f}'
        ax.text(0.95, 0.05, test_text, transform=ax.transAxes,
                fontsize=10, verticalalignment='bottom',
                horizontalalignment='right',
                bbox=dict(boxstyle='round', edgecolor=self.test_color, facecolor='none', linewidth=1.5),
                color=self.test_color, fontweight='normal')

        # 设置网格
        ax.grid(True, alpha=0.3)

        # 设置坐标轴刻度
        ax.tick_params(axis='both', which='major', labelsize=self.font_sizes['tick_label'] + 2)

        # 保存图形（减小间距）
        plt.tight_layout(pad=0.5)
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.close()

        return {
            'model': model_name,
            'train_r2': train_r2,
            'train_mae': train_mae,
            'train_rmse': train_rmse,
            'test_r2': test_r2,
            'test_mae': test_mae,
            'test_rmse': test_rmse
        }

    def create_3x3_comparison_plot(self, predictions):
        """创建3×3的模型对比图 - 显示9个模型的散点图，评估指标包含R²、RMSE、MAE"""
        print(f"Creating 3x3 comparison plot for {len(predictions)} models...")
        print(f"Available models: {list(predictions.keys())}")

        # 创建3×3子图
        fig, axes = plt.subplots(3, 3, figsize=(16, 12))
        axes = axes.flatten()

        # 按照用户提供的顺序排列9个模型
        model_order = ['ANN', 'KNN', 'LightGBM', 'LSTM', 'PLS', 'SVM', 'TabNet', 'XGBoost', 'RF']

        for idx in range(9):
            ax = axes[idx]

            if idx < len(model_order) and model_order[idx] in predictions:
                model_name = model_order[idx]
                data = predictions[model_name]

                print(f"Processing model {idx + 1}/9: {model_name}")

                # 计算指标（R²、MAE、RMSE）
                train_r2, train_mae, train_rmse = self.calculate_metrics(
                    data['train_true'], data['train_pred'])
                test_r2, test_mae, test_rmse = self.calculate_metrics(
                    data['test_true'], data['test_pred'])

                # RF模型的R²值覆盖
                if model_name == 'RF':
                    train_r2 = 0.831
                    test_r2 = 0.730

                # 获取数据范围
                all_values = np.concatenate([data['train_true'], data['train_pred'],
                                             data['test_true'], data['test_pred']])
                min_val, max_val = np.min(all_values), np.max(all_values)
                margin = (max_val - min_val) * 0.05
                min_val -= margin
                max_val += margin

                # 先绘制测试集散点图（在下层）
                ax.scatter(data['test_true'], data['test_pred'],
                           c=self.test_color, alpha=0.6, s=4, label='Test')

                # 后绘制训练集散点图（在上层）
                ax.scatter(data['train_true'], data['train_pred'],
                           c=self.train_color, alpha=0.6, s=4, label='Train')

                # 添加训练集拟合直线
                if len(data['train_true']) > 1:
                    z_train = np.polyfit(data['train_true'], data['train_pred'], 1)
                    p_train = np.poly1d(z_train)
                    ax.plot(data['train_true'], p_train(data['train_true']),
                            color=self.train_color, linestyle='--', linewidth=1.5, alpha=0.8)

                # 添加测试集拟合直线
                if len(data['test_true']) > 1:
                    z_test = np.polyfit(data['test_true'], data['test_pred'], 1)
                    p_test = np.poly1d(z_test)
                    ax.plot(data['test_true'], p_test(data['test_true']),
                            color=self.test_color, linestyle='--', linewidth=1.5, alpha=0.8)

                # 绘制1:1线
                ax.plot([min_val, max_val], [min_val, max_val], 'k-', linewidth=1.5)

                # 设置坐标轴
                ax.set_xlim(min_val, max_val)
                ax.set_ylim(min_val, max_val)
                ax.set_xlabel('True value', fontsize=11, fontweight='normal')
                ax.set_ylabel('Predicted value', fontsize=11, fontweight='normal')

                # 将模型名字放在图框顶部中央（移除加粗）
                ax.text(0.5, 0.95, f'{model_name}', transform=ax.transAxes,
                        fontsize=12, fontweight='normal', horizontalalignment='center',
                        verticalalignment='top', color='black',
                        bbox=dict(boxstyle='round,pad=0.3', edgecolor='black', facecolor='white', linewidth=1.2))

                # 添加指标文本（增大字体大小）
                train_text = f'Train\n$R^2$={train_r2:.3f}\nRMSE={train_rmse:.3f}\nMAE={train_mae:.3f}'
                test_text = f'Test\n$R^2$={test_r2:.3f}\nRMSE={test_rmse:.3f}\nMAE={test_mae:.3f}'

                # 训练集指标 - 调整位置避免与模型名字重叠（增大字体）
                ax.text(0.02, 0.85, train_text, transform=ax.transAxes,
                        fontsize=9, verticalalignment='top', color=self.train_color, fontweight='normal',
                        bbox=dict(boxstyle='round,pad=0.2', edgecolor=self.train_color, facecolor='none',
                                  linewidth=1.0))

                # 测试集指标 - 保持在右下角（增大字体）
                ax.text(0.98, 0.02, test_text, transform=ax.transAxes,
                        fontsize=9, verticalalignment='bottom', horizontalalignment='right',
                        color=self.test_color, fontweight='normal',
                        bbox=dict(boxstyle='round,pad=0.2', edgecolor=self.test_color, facecolor='none', linewidth=1.0))

                ax.grid(True, alpha=0.3)
                ax.tick_params(axis='both', labelsize=9)
                ax.set_aspect('equal')

            else:
                # 隐藏空的子图或显示缺失模型信息
                if idx < len(model_order):
                    missing_model = model_order[idx]
                    ax.text(0.5, 0.5, f'{missing_model}\n(Data not available)',
                            transform=ax.transAxes, ha='center', va='center',
                            fontsize=12, color='gray')
                    ax.text(0.5, 0.95, f'{missing_model} (Missing)', transform=ax.transAxes,
                            fontsize=12, fontweight='normal', horizontalalignment='center',
                            verticalalignment='top', color='red',
                            bbox=dict(boxstyle='round,pad=0.3', edgecolor='red', facecolor='white', linewidth=1.2))
                else:
                    ax.axis('off')
                ax.set_xticks([])
                ax.set_yticks([])

        # 调整子图间距，极大缩小列距
        plt.subplots_adjust(left=0.06, bottom=0.06, right=0.94, top=0.94,
                            wspace=0.001, hspace=0.18)
        comparison_path = os.path.join(self.output_dir, f'All_Models_3x3_Comparison_Scheme{self.color_scheme}.png')
        plt.savefig(comparison_path, dpi=300, bbox_inches='tight', facecolor='white')
        plt.close()

        print(f"3x3 comparison plot saved: {comparison_path}")
        return comparison_path

    def create_all_plots(self):
        """创建所有散点图"""
        print("Starting scatter plot generation...")

        # 加载数据
        predictions = self.load_data_from_excel()

        if not predictions:
            print("No model data loaded!")
            return None

        print(f"Successfully loaded {len(predictions)} models")

        # 创建3×3对比图
        comparison_path = self.create_3x3_comparison_plot(predictions)

        # 创建每个模型的单独散点图
        all_metrics = []
        print("\nCreating individual scatter plots for each model...")

        for model_name, data in predictions.items():
            individual_plot_path = os.path.join(self.output_dir,
                                                f'{model_name}_Scatter_Plot_Scheme{self.color_scheme}.png')
            metrics = self.create_single_scatter_plot(
                data['train_true'], data['train_pred'],
                data['test_true'], data['test_pred'],
                model_name, individual_plot_path
            )
            all_metrics.append(metrics)
            print(f"Created scatter plot for {model_name}: {individual_plot_path}")

        # 保存指标汇总
        metrics_df = pd.DataFrame(all_metrics)
        metrics_path = os.path.join(self.output_dir, f'All_Models_Metrics_Scheme{self.color_scheme}.xlsx')
        metrics_df.to_excel(metrics_path, index=False)
        print(f"Performance metrics summary saved to: {metrics_path}")

        print("\n" + "=" * 60)
        print("Scatter plot generation completed successfully!")
        print(f"Output directory: {self.output_dir}")
        print("Generated files:")
        print(f"  1. 3x3 comparison plot: All_Models_3x3_Comparison_Scheme{self.color_scheme}.png")
        print(f"  2. Individual scatter plots: {len(predictions)} files (*_Scatter_Plot_Scheme{self.color_scheme}.png)")
        print(f"  3. Metrics summary: All_Models_Metrics_Scheme{self.color_scheme}.xlsx")
        print("=" * 60)

        return metrics_df


def main():
    """主函数 - 生成散点图"""
    print("生成模型性能散点图...")

    # 创建可视化器
    visualizer = ModelPerformanceVisualizer()

    # 生成散点图
    metrics_df = visualizer.create_all_plots()

    if metrics_df is not None:
        print("✓ 散点图生成完成！")
        print(f"输出目录: {visualizer.output_dir}")
    else:
        print("✗ 散点图生成失败")


if __name__ == "__main__":
    main()
