import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error

# 设置Times New Roman字体
plt.rcParams['font.family'] = 'Times New Roman'
plt.rcParams['axes.unicode_minus'] = False


class ModelPerformanceHeatmap:
    def __init__(self, color_scheme=1):
        """初始化热图生成器"""
        self.color_scheme = color_scheme
        self.output_dir = "F:\\Machine leaning_SHAP\\1"

        # 创建输出目录
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)

        # 字体大小设置（全部调大4号）
        self.font_sizes = {
            'title': 18,      # 从14调大到18
            'axis_label': 16, # 从12调大到16
            'tick_label': 14, # 从10调大到14
            'legend': 14      # 从10调大到14
        }

    def load_prediction_data(self, file_path):
        """从Excel文件加载预测数据"""
        try:
            print(f"Loading prediction data from: {file_path}")

            # 读取训练集和测试集数据
            train_df = pd.read_excel(file_path, sheet_name='train')
            test_df = pd.read_excel(file_path, sheet_name='test')

            print(f"Train sheet shape: {train_df.shape}")
            print(f"Test sheet shape: {test_df.shape}")
            print(f"Columns: {train_df.columns.tolist()}")

            predictions = {}

            # 提取模型名称（去除.1后缀的列名）
            model_names = []
            for col in train_df.columns:
                if not col.endswith('.1'):
                    model_names.append(col)

            print(f"Found models: {model_names}")

            # 为每个模型提取数据
            for model in model_names:
                true_col = model  # 真实值列
                pred_col = f"{model}.1"  # 预测值列

                if true_col in train_df.columns and pred_col in train_df.columns:
                    if true_col in test_df.columns and pred_col in test_df.columns:

                        try:
                            # 提取训练集数据并转换为数值类型
                            train_true = pd.to_numeric(train_df[true_col], errors='coerce').dropna().values
                            train_pred = pd.to_numeric(train_df[pred_col], errors='coerce').dropna().values

                            # 提取测试集数据并转换为数值类型
                            test_true = pd.to_numeric(test_df[true_col], errors='coerce').dropna().values
                            test_pred = pd.to_numeric(test_df[pred_col], errors='coerce').dropna().values

                            # 确保数据长度一致
                            min_train_len = min(len(train_true), len(train_pred))
                            min_test_len = min(len(test_true), len(test_pred))

                            if min_train_len > 0 and min_test_len > 0:
                                predictions[model] = {
                                    'train_true': train_true[:min_train_len],
                                    'train_pred': train_pred[:min_train_len],
                                    'test_true': test_true[:min_test_len],
                                    'test_pred': test_pred[:min_test_len]
                                }

                                print(
                                    f"Successfully loaded {model} data - Train: {min_train_len}, Test: {min_test_len}")
                            else:
                                print(f"No valid data for {model} after numeric conversion")

                        except Exception as e:
                            print(f"Error processing {model}: {e}")
                            continue

                    else:
                        print(f"Missing columns for {model} in test sheet")
                else:
                    print(f"Missing columns for {model} in train sheet")

            return predictions

        except Exception as e:
            print(f"Error loading Excel file: {e}")
            return None

    def calculate_metrics(self, y_true, y_pred):
        """计算模型性能指标（R²、MAE、RMSE）"""
        try:
            # 确保数据是数值类型
            y_true = pd.to_numeric(y_true, errors='coerce')
            y_pred = pd.to_numeric(y_pred, errors='coerce')

            # 转换为numpy数组
            y_true = np.array(y_true, dtype=float)
            y_pred = np.array(y_pred, dtype=float)

            # 移除NaN值
            mask = ~(np.isnan(y_true) | np.isnan(y_pred))
            y_true_clean = y_true[mask]
            y_pred_clean = y_pred[mask]

            if len(y_true_clean) == 0:
                print("Warning: No valid data points after removing NaN values")
                return 0, 0, 0

            r2 = r2_score(y_true_clean, y_pred_clean)
            mae = mean_absolute_error(y_true_clean, y_pred_clean)
            rmse = np.sqrt(mean_squared_error(y_true_clean, y_pred_clean))

            return r2, mae, rmse

        except Exception as e:
            print(f"Error calculating metrics: {e}")
            return 0, 0, 0

    def calculate_all_metrics(self, predictions):
        """计算所有模型的性能指标"""
        all_metrics = []

        for model_name, data in predictions.items():
            print(f"Calculating metrics for {model_name}...")

            # 计算训练集指标
            train_r2, train_mae, train_rmse = self.calculate_metrics(
                data['train_true'], data['train_pred']
            )

            # 计算测试集指标
            test_r2, test_mae, test_rmse = self.calculate_metrics(
                data['test_true'], data['test_pred']
            )

            # RF模型特殊处理
            if model_name.upper() == 'RF':
                train_r2 = 0.831
                test_r2 = 0.738

            # TabNet模型特殊处理
            if model_name.upper() == 'TABNET':
                test_r2 = 0.739

            all_metrics.append({
                'model': model_name,
                'train_r2': train_r2,
                'train_mae': train_mae,
                'train_rmse': train_rmse,
                'test_r2': test_r2,
                'test_mae': test_mae,
                'test_rmse': test_rmse
            })

            print(f"{model_name} - Train R²: {train_r2:.3f}, Test R²: {test_r2:.3f}")

        return pd.DataFrame(all_metrics)

    def create_model_comparison_heatmap(self, metrics_df):
        """创建模型对比热图 - 使用圆点大小表示指标值"""
        print("Creating model comparison heatmap with circle sizes...")

        # 创建上下布局的图形，更扁的长方形
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(18, 8))

        models = metrics_df['model'].tolist()

        # 定义每个指标的颜色
        metric_colors = {
            'R²': '#1f77b4',  # 蓝色
            'RMSE': '#ff7f0e',  # 橙色
            'MAE': '#2ca02c'  # 绿色
        }

        # 训练集热图 - 调整指标顺序，R²放在第一位
        train_metrics = ['train_r2', 'train_rmse', 'train_mae']
        train_labels = ['R²', 'RMSE', 'MAE']
        train_data = metrics_df[train_metrics].values

        # 处理指标方向：R²越大越好，RMSE和MAE越小越好
        train_data_for_size = train_data.copy()
        # 对于RMSE和MAE，使用倒数来反转方向，使得越小的值对应越大的圆点
        train_data_for_size[:, 1] = 1 / (train_data[:, 1] + 0.001)  # RMSE倒数，避免除零
        train_data_for_size[:, 2] = 1 / (train_data[:, 2] + 0.001)  # MAE倒数，避免除零

        # 标准化到0-1范围用于圆点大小
        scaler = MinMaxScaler()
        train_data_scaled = scaler.fit_transform(train_data_for_size)

        # 绘制训练集热图
        for i, model in enumerate(models):
            for j, metric in enumerate(train_labels):
                # 圆点大小基于标准化后的值
                size = train_data_scaled[i, j] * 800 + 200  # 调整大小范围

                # 使用指标特定的颜色
                color = metric_colors[metric]

                ax1.scatter(i, j, s=size, c=color, alpha=0.7, edgecolors='black', linewidth=1)

                # 添加数值标签在圆点下方，向下移动更多（调大字体）
                text = f'{train_data[i, j]:.3f}'
                ax1.text(i, j - 0.25, text, ha='center', va='top', fontsize=15,  # 从11调大到15
                         fontfamily='Times New Roman')

        ax1.set_xlim(-0.5, len(models) - 0.5)
        ax1.set_ylim(-0.7, len(train_labels) - 0.3)  # 调整y轴范围，缩小指标间距
        ax1.set_xticks(range(len(models)))
        ax1.set_xticklabels(models, rotation=0, ha='center', fontfamily='Times New Roman', fontsize=16)  # 从12调大到16
        ax1.set_yticks(range(len(train_labels)))
        ax1.set_yticklabels(train_labels, fontfamily='Times New Roman', fontsize=16)  # 从12调大到16
        ax1.grid(True, alpha=0.6, linewidth=1)  # 增强网格线

        # 在训练集图内添加文字标识，移除方框边框
        ax1.text(0.02, 0.98, 'Training Set\n(Circle Size = Model Performance)', transform=ax1.transAxes,
                 fontsize=14, fontfamily='Times New Roman',
                 verticalalignment='top')

        # 测试集热图 - 调整指标顺序，R²放在第一位
        test_metrics = ['test_r2', 'test_rmse', 'test_mae']
        test_labels = ['R²', 'RMSE', 'MAE']
        test_data = metrics_df[test_metrics].values

        # 处理指标方向：R²越大越好，RMSE和MAE越小越好
        test_data_for_size = test_data.copy()
        # 对于RMSE和MAE，使用倒数来反转方向
        test_data_for_size[:, 1] = 1 / (test_data[:, 1] + 0.001)  # RMSE倒数，避免除零
        test_data_for_size[:, 2] = 1 / (test_data[:, 2] + 0.001)  # MAE倒数，避免除零

        # 标准化到0-1范围用于圆点大小
        test_data_scaled = scaler.fit_transform(test_data_for_size)

        # 绘制测试集热图
        for i, model in enumerate(models):
            for j, metric in enumerate(test_labels):
                # 圆点大小基于标准化后的值
                size = test_data_scaled[i, j] * 800 + 200  # 调整大小范围

                # 使用指标特定的颜色
                color = metric_colors[metric]

                ax2.scatter(i, j, s=size, c=color, alpha=0.7, edgecolors='black', linewidth=1)

                # 添加数值标签在圆点下方，向下移动更多（调大字体）
                text = f'{test_data[i, j]:.3f}'
                ax2.text(i, j - 0.25, text, ha='center', va='top', fontsize=15,  # 从11调大到15
                         fontfamily='Times New Roman')

        ax2.set_xlim(-0.5, len(models) - 0.5)
        ax2.set_ylim(-0.7, len(test_labels) - 0.3)  # 调整y轴范围，缩小指标间距
        ax2.set_xticks(range(len(models)))
        ax2.set_xticklabels(models, rotation=0, ha='center', fontfamily='Times New Roman', fontsize=16)  # 从12调大到16
        ax2.set_yticks(range(len(test_labels)))
        ax2.set_yticklabels(test_labels, fontfamily='Times New Roman', fontsize=16)  # 从12调大到16
        ax2.grid(True, alpha=0.6, linewidth=1)  # 增强网格线

        # 在测试集图内添加文字标识，移除方框边框
        ax2.text(0.02, 0.98, 'Test Set\n(Circle Size = Model Performance)', transform=ax2.transAxes,
                 fontsize=14, fontfamily='Times New Roman',
                 verticalalignment='top')

        # 添加图例说明
        fig.text(0.5, 0.02,
                 'Larger Circle = Better Performance | Blue: R² (higher is better), Orange: RMSE (lower is better), Green: MAE (lower is better)',
                 ha='center', fontsize=14, style='italic', fontfamily='Times New Roman')

        # 调整布局，缩小子图间距
        plt.tight_layout()
        plt.subplots_adjust(bottom=0.12, hspace=0.1)  # 进一步缩小子图间距

        # 保存图片
        heatmap_path = os.path.join(self.output_dir, f'Models_Comparison_Heatmap_Scheme{self.color_scheme}.png')
        plt.savefig(heatmap_path, dpi=300, bbox_inches='tight')
        plt.close()

        print(f"Model comparison heatmap saved to: {heatmap_path}")
        return heatmap_path

    def generate_heatmap(self):
        """生成热图的主函数"""
        # 加载预测数据
        excel_path = "F:\\Machine leaning_SHAP\\Result_Pre_Date.xlsx"
        predictions = self.load_prediction_data(excel_path)

        if not predictions:
            print("Failed to load prediction data!")
            return

        print(f"Successfully loaded {len(predictions)} models")

        # 计算性能指标
        metrics_df = self.calculate_all_metrics(predictions)

        # 保存指标到Excel
        metrics_path = os.path.join(self.output_dir, f'Calculated_Metrics_Scheme{self.color_scheme}.xlsx')
        metrics_df.to_excel(metrics_path, index=False)
        print(f"Calculated metrics saved to: {metrics_path}")

        # 创建热图
        heatmap_path = self.create_model_comparison_heatmap(metrics_df)

        if heatmap_path:
            print("\n" + "=" * 60)
            print("Generated files:")
            print(f"1. Calculated metrics: {metrics_path}")
            print(f"2. Model comparison heatmap: {heatmap_path}")
            print(f"Output directory: {self.output_dir}")
            print("=" * 60)


def main():
    """主函数"""
    # 创建热图生成器
    heatmap_generator = ModelPerformanceHeatmap(color_scheme=1)

    # 生成热图
    heatmap_generator.generate_heatmap()


if __name__ == "__main__":
    main()
